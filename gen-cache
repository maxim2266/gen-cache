#!/bin/sh -e

usage() {
	cat >&2 <<EOF
Usage: $(basename "$0") -k/--key TYPE -v/--value TYPE -n/--name NAME -p/--package NAME [-o/--output FILE]
  Generate Go source code for a cache for the given types of keys and values,
  with the given name, and included in the given package.
EOF
	exit 1
}

die() {
	echo >&2 "$(basename "$0"): error:" "$@"
	exit 1
}

# close stdin
exec 0<&-

# parameter parsing
[ $# -gt 0 ] || usage

while [ $# -gt 0 ]; do
	case "$1" in
		-h|--help)
			usage
			;;
		-k|--key)
			[ $# -gt 1 ] || die "missing parameter for \"-k/--key\" option"
			key="$2"
			shift 2
			;;
		-v|--value)
			[ $# -gt 1 ] || die "missing parameter for \"-v/--value\" option"
			value="$2"
			shift 2
			;;
		-n|--name)
			[ $# -gt 1 ] || die "missing parameter for \"-n/--name\" option"
			name="$2"
			shift 2
			;;
		-p|--package)
			[ $# -gt 1 ] || die "missing parameter for \"-p/--package\" option"
			package="$2"
			shift 2
			;;
		-o|--output)
			[ $# -gt 1 ] || die "missing parameter for \"-o/--output\" option"
			dest="$2"
			shift 2
			;;
		*)
			die "unknown option \"$1\""
			;;
	esac
done

# validate parameters
[ -n "$key" ] || die "key type is not specified"
[ -n "$value" ] || die "value type is not specified"
[ -n "$name" ] || die "cache name is not specified"
[ -n "$package" ] || die "package name is not specified"

# public/private name versions
u_name=$(echo "$name" | sed 's/^[[:lower:]]/\U&/')
l_name=$(echo "$name" | sed 's/^[[:upper:]]/\L&/')

if [ "$u_name" = "$name" ]
then
	constructor="New${u_name}"
else
	constructor="new${u_name}"
fi

# code generator
gen() {
	sed -E	\
		-e "s/\\<K\\>/$key/g"	\
		-e "s/\\<V\\>/$value/g"	\
		-e "s/\\<Cache\\>/${name}/g"	\
		-e "s/\\<CacheNode\\>/${l_name}Node/g"	\
	| goimports
}

# generate the code
[ -n "$dest" ] && exec > "$dest"

gen <<EOF
// AUTOMATICALLY GENERATED FILE - DO NOT EDIT

package $package

// Cache is an opaque type representing a cache with keys of type "K" and values of type "V".
type Cache struct {
	mu    sync.Mutex
	cache map[K]*CacheNode
	lru   *CacheNode

	size  int
	ttl   time.Duration
	backend func(K) (V, error)
}

type CacheNode struct {
	prev, next *CacheNode
	once       sync.Once

	key   K
	value V
	err   error
	ts    time.Time
}

// $constructor creates a new Cache with keys of type "K" and values of type "V".
func ${constructor}(size int, ttl time.Duration, backend func(K) (V, error)) *Cache {
	if size < 2 || size > 16*1024*1024 {
		panic(fmt.Sprintf("attempted to create Cache with invalid capacity of %d items", size))
	}

	if backend == nil {
		panic("attempted to create Cache with nil backend() function")
	}

	return &Cache{
		cache: make(map[K]*CacheNode, size),
		size:  size,
		ttl:   ttl,
		backend: backend,
	}
}

// Get retrieves the value associated with the given key, invoking backend where necessary.
func (c *Cache) Get(key K) (V, error) {
	node := c.get(key)

	node.once.Do(func() {
		defer func() {
			if p := recover(); p != nil {
				node.err = fmt.Errorf("panic: %+v", p)
				panic(p)
			}
		}()

		node.value, node.err = c.backend(key)
	})

	return node.value, node.err
}

// Delete evicts the given key from the cache.
func (c *Cache) Delete(key K) {
	c.mu.Lock()
	defer c.mu.Unlock()

	if node := c.cache[key]; node != nil {
		c.lruRemove(node)
		node.next, node.prev = nil, nil // help gc
		delete(c.cache, key)
	}
}

func (c *Cache) get(key K) (node *CacheNode) {
	c.mu.Lock()
	defer c.mu.Unlock()

	if node = c.cache[key]; node != nil { // found
		c.lruRemove(node)

		if time.Since(node.ts) > c.ttl {
			node.next, node.prev = nil, nil // help gc
			node = c.newNode(node.key)
		}
	} else { // not found
		if len(c.cache) == c.size { // cache full
			// delete the least recent
			node = c.lru
			c.lru = node.prev
			node.prev.next, node.next.prev = node.next, node.prev
			node.next, node.prev = nil, nil // help gc
			delete(c.cache, node.key)
		}

		node = c.newNode(key)
	}

	// add the node as the most recent
	if c.lru == nil {
		c.lru = node
		node.next, node.prev = node, node
	} else {
		node.next, node.prev = c.lru.next, c.lru
		node.next.prev, node.prev.next = node, node
	}

	return
}

func (c *Cache) newNode(key K) (node *CacheNode) {
	node = &CacheNode{
		key: key,
		ts:  time.Now(),
	}

	c.cache[key] = node
	return
}

func (c *Cache) lruRemove(node *CacheNode) {
	if node.next == node {
		c.lru = nil
	} else {
		if c.lru == node {
			c.lru = node.prev
		}

		node.prev.next, node.next.prev = node.next, node.prev
	}
}
EOF